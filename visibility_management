using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Collections.Specialized;
using UnityEngine.UI;
using UnityEngine;
using TMPro;
using System.Threading.Tasks;
using System.Diagnostics;
using UnityEngine.AI;
using UMA;
using UMA.PoseTools;
using UMA.Dynamics;
using UMA.CharacterSystem;
using FoW;

public class visibility_management : MonoBehaviour
{

    void Start()
    {
     
    }

    public game_clock gc;
    public FogOfWar fow;

    int current_base_x = 1;
    int current_base_y = 1;
    Vector3 world_position;

    public void tile_determiner()
    {
        Parallel.For(current_base_y, current_base_y + Environment.ProcessorCount * 2, index => { 
            int y_to_try = current_base_y;
            int x_to_try = current_base_x;
            if (index <= gc.world_map_length)
            {
                y_to_try = index;
            }
            else
            {
                y_to_try = index - gc.world_map_length;
                x_to_try += 1;
            }
            if (x_to_try > gc.world_map_width)
            {
                x_to_try = 1;
            }
            details_visibility_determiner(x_to_try, y_to_try);
        });
        current_base_y = current_base_y + Environment.ProcessorCount * 4;
        if(current_base_y > gc.world_map_length)
        {
            current_base_y = current_base_y - gc.world_map_length;
            current_base_x += 1;
        }
        if (current_base_x > gc.world_map_width)
        {
            current_base_x = 1;
        }
    }

    ConcurrentQueue<MeshRenderer> renderers_to_enable = new ConcurrentQueue<MeshRenderer>();
    ConcurrentQueue<MeshRenderer> renderers_to_disable = new ConcurrentQueue<MeshRenderer>();

    ConcurrentQueue<SkinnedMeshRenderer> skm_renderers_to_enable = new ConcurrentQueue<SkinnedMeshRenderer>();
    ConcurrentQueue<SkinnedMeshRenderer> skm_renderers_to_disable = new ConcurrentQueue<SkinnedMeshRenderer>();

    ConcurrentQueue<ParticleSystem> ps_to_enable = new ConcurrentQueue<ParticleSystem>();
    ConcurrentQueue<ParticleSystem> ps_to_disable = new ConcurrentQueue<ParticleSystem>();

    public void details_visibility_determiner(int x, int y)
    {
        // Settlements, Infrastructure, and Trees
        world_position = new Vector3((5 * gc.world_map_width - 10 * x), 0, (5 * gc.world_map_length - 10 * y));
        if (gc.infrastructure_and_settlement_renderers.ContainsKey(new Vector2(x, y)))
        {
            if (gc.infrastructure_and_settlement_renderers[new Vector2(x, y)] != null)
            {
                if (gc.tiles_and_sovereignty[new Vector2(x, y)] != null)
                {
                    // Make Invisible
                    if (!(gc.tiles_and_sovereignty[new Vector2(x, y)] == gc.player_tribal_empty
                    | gc.map_visibility_sharing[gc.tiles_and_sovereignty[new Vector2(x, y)]].Contains(gc.player_tribal_empty)
                    | gc.espionage_relations[gc.player_tribal_empty].Contains(gc.tiles_and_sovereignty[new Vector2(x, y)])))
                    {
                        for(int i = 0; i <= gc.infrastructure_and_settlement_renderers[new Vector2(x, y)].Count() - 1; i++)
                        {
                            renderers_to_disable.Enqueue(gc.infrastructure_and_settlement_renderers[new Vector2(x, y)][i]);
                        }
                        for (int i = 0; i <= gc.skinned_mesh_renderers[new Vector2(x, y)].Count() - 1; i++)
                        {
                            skm_renderers_to_disable.Enqueue(gc.skinned_mesh_renderers[new Vector2(x, y)][i]);
                        }
                        for (int i = 0; i <= gc.particle_systems[new Vector2(x, y)].Count() - 1; i++)
                        {
                            ps_to_disable.Enqueue(gc.particle_systems[new Vector2(x, y)][i]);
                        }
                        // Add Fake Renderers to Enable
                        for (int k = 0; k <= gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)].Count() - 1; k++)
                        {
                            renderers_to_enable.Enqueue(gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)][k]);
                        }
                    }
                    // Make Visible
                    else
                    {
                        for (int i = 0; i <= gc.infrastructure_and_settlement_renderers[new Vector2(x, y)].Count() - 1; i++)
                        {
                            renderers_to_enable.Enqueue(gc.infrastructure_and_settlement_renderers[new Vector2(x, y)][i]);
                        }
                        for (int i = 0; i <= gc.skinned_mesh_renderers[new Vector2(x, y)].Count() - 1; i++)
                        {
                            skm_renderers_to_enable.Enqueue(gc.skinned_mesh_renderers[new Vector2(x, y)][i]);
                        }
                        for (int i = 0; i <= gc.particle_systems[new Vector2(x, y)].Count() - 1; i++)
                        {
                            ps_to_enable.Enqueue(gc.particle_systems[new Vector2(x, y)][i]);
                        }
                        //  Add Fake Renderers to Disable
                        for (int k = 0; k <= gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)].Count() - 1; k++)
                        {
                            renderers_to_disable.Enqueue(gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)][k]);
                        }
                    }
                }
                else
                {
                    // Make Invisible
                    for (int i = 0; i <= gc.infrastructure_and_settlement_renderers[new Vector2(x, y)].Count() - 1; i++)
                    {
                        renderers_to_disable.Enqueue(gc.infrastructure_and_settlement_renderers[new Vector2(x, y)][i]);                    
                    }
                    for (int i = 0; i <= gc.skinned_mesh_renderers[new Vector2(x, y)].Count() - 1; i++)
                    {
                        skm_renderers_to_disable.Enqueue(gc.skinned_mesh_renderers[new Vector2(x, y)][i]);
                    }
                    for (int i = 0; i <= gc.particle_systems[new Vector2(x, y)].Count() - 1; i++)
                    {
                        ps_to_disable.Enqueue(gc.particle_systems[new Vector2(x, y)][i]);
                    }
                    // Add Fake Renderers to Enable
                    for (int k = 0; k <= gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)].Count() - 1; k++)
                    {
                        renderers_to_enable.Enqueue(gc.infrastructure_and_settlement_fake_renderers[new Vector2(x, y)][k]);
                    }
                }
            }
        }
    }

    // Update is called once per frame
    public void Update()
    {
        tile_determiner();
        foreach (MeshRenderer mr in renderers_to_enable)
        {
            if (mr)
            {
                if (mr.gameObject)
                {
                    mr.enabled = true;
                }
            }
        }
        foreach (SkinnedMeshRenderer smr in skm_renderers_to_enable)
        {
            if (smr)
            {
                if (smr.gameObject)
                {
                    smr.enabled = true;
                }
            }
        }
        foreach(ParticleSystem ps in ps_to_enable)
        {
            if (ps)
            {
                if (ps.gameObject)
                {
                    if (!ps.isPlaying)
                    {
                        ps.Play();
                    }
                }
            }
        }
        renderers_to_enable = new ConcurrentQueue<MeshRenderer>();
        skm_renderers_to_enable = new ConcurrentQueue<SkinnedMeshRenderer>();
        ps_to_enable = new ConcurrentQueue<ParticleSystem>();
        if(gc.revealed_map == false)
        {
            foreach (MeshRenderer mr in renderers_to_disable)
            {
                if (mr)
                {
                    if (mr.gameObject)
                    {
                        mr.enabled = false;
                    }
                }
            }
            foreach (SkinnedMeshRenderer smr in skm_renderers_to_disable)
            {
                if (smr)
                {
                    if (smr.gameObject)
                    {
                        smr.enabled = false;
                    }
                }
            }
            foreach (ParticleSystem ps in ps_to_disable)
            {
                if (ps)
                {
                    if (ps.gameObject)
                    {
                        ps.Stop();
                    }
                }
            }
        }
        renderers_to_disable = new ConcurrentQueue<MeshRenderer>();
        skm_renderers_to_disable = new ConcurrentQueue<SkinnedMeshRenderer>();
        ps_to_disable = new ConcurrentQueue<ParticleSystem>();
    }
}
